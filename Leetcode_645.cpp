/*
* 645. 错误的集合
*
* 集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。
* 给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。
* 
*
* 
* 解题思路： 
*   数组的值和 1~n 异或 的救国，正好是重复数和丢失数的异或结果，因为 a^b^a^c=b^c, 相同的数异或结果是 0
*   接下来的重点是，把两数的 异或结果分离， 采用的方法是
*       以异或结果二进制最右位的 1 作为标志位，使数组的值分为两组，并使 1~n 分为两组，
*       再次使 数组和 1~n 异或，这次由于分为两组，所以得到了两个值，一个为 重复数，另一个为丢失数
*       再循环一次，出现两次的数为 重复数 ，另一个就是丢失数
*/

class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        int size = nums.size();
        unordered_set<int> mySet;
        int s = 0;
        //第一步，求得 重复数和丢失数的 异或结果 s
        for(int i=0;i < size;i++)
        {
            s ^= nums[i];
            s ^= i+1;
        }
        //int nFlag = s & -s;
        //第二步， 由于重复数与丢失数必然不同，所以 求得两数不同点的最右位二进制1 nFlag
        // 与第一步类似，再异或两次，和 1~n 异或一次， 和 nums[0]~nums[n-1] 异或一次。
        // 但是这次不同的地方是， 使用 nFlag 使遍历的值分为两组，并使用两个变量分别异或， i&n==0 一组，其他再一组。
        // 这两个变量里分别存了 重复数和丢失数
        //  12345  12335 ， 重复数 异或了三次， 丢失数异或了一次
        // 但是不清楚到底哪个是重复数，哪个是丢失数
        int nFlag = s & ~(s-1);
        int x1=0, x2=0, nCount=0;
        for(int i=1;i <= size;i++){
            if((i&nFlag) == 0)
            {
                x1 ^= i;
            }else
                x2 ^= i;
        }

        for(int i=0;i < size;i++){
            if((nums[i]&nFlag)==0)
                x1 ^= nums[i];
            else
                x2 ^= nums[i];
        }
        //第三步 再遍历一次， 重复数出现次数为2，丢失数为0.
        for(int i=0;i < size;i++){
            if(x1 == nums[i])
                nCount++;
        }
        if(nCount == 0)
            return {x2,x1};
        else   
            return {x1,x2};
    }
};